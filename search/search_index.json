{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Eye Platform Documentation Portal","text":"<p>Welcome to the unified documentation hub. Choose a module below:</p> <ul> <li>EyeAgent \u2013 multi-agent orchestration, tool invocation &amp; integration  </li> <li>Go to: EyeAgent Docs</li> <li>EyeTools \u2013 tool registration, discovery, execution &amp; CLI support  </li> <li>Go to: EyeTools Docs</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>EyeAgent: Quick Start | Architecture</li> <li>EyeTools: Quick Start | Architecture</li> </ul> <p>Some links may be placeholders if the corresponding document is still being written.</p>"},{"location":"eyeagent/","title":"EyeAgent Documentation","text":"<p>Welcome to the EyeAgent documentation. This project provides multi-agent orchestration capabilities and tool integration, working with EyeTools for automatic tool discovery and invocation.</p>"},{"location":"eyeagent/#contents","title":"Contents","text":"<ul> <li>Quick Start</li> <li>Architecture</li> <li>(More sections will be added)</li> </ul>"},{"location":"eyeagent/#tool-outputs-ui","title":"Tool Outputs &amp; UI","text":"<p>EyeAgent expects unified tool outputs across types. The agents standardize common fields (label, probabilities, probability/predicted for disease-specific, counts/areas for segmentation) while preserving original keys.</p> <p>The MCP server wraps raw tool output with a <code>__meta__</code> block (tool_id, inputs, ts). Agents unwrap this and attach <code>mcp_meta</code> to trace events. The UI shows core fields and a small gray header with the tool id and timestamp for each tool bubble.</p>"},{"location":"eyeagent/architecture/","title":"Architecture Overview","text":"<p>EyeAgent is responsible for: - Multi-agent coordination (roles, message routing) - Interfacing with the tool layer (EyeTools) to execute perception / analysis tools - Unified logging and configuration management</p> <p>A detailed architecture description will be added in future revisions.</p>"},{"location":"eyeagent/architecture_diagnosis/","title":"\u773c\u79d1\u591a\u667a\u80fd\u4f53\u8bca\u65ad\u7cfb\u7edf\u67b6\u6784\u8bbe\u8ba1","text":""},{"location":"eyeagent/architecture_diagnosis/#_2","title":"\u7cfb\u7edf\u76ee\u6807","text":"<p>\u8f93\u5165\uff1a\u60a3\u8005\u57fa\u672c\u8d44\u6599\uff08\u5e74\u9f84\u3001\u6027\u522b\u3001\u4e3b\u8bc9\u3001\u65e2\u5f80\u53f2\u7b49\uff09+ \u591a\u6a21\u6001\u773c\u79d1\u5f71\u50cf\uff08CFP\u3001OCT\u3001FFA ...\uff09\\n\u8f93\u51fa\uff1a\u7ed3\u6784\u5316\u8bca\u65ad\u62a5\u544a\uff08\u75be\u75c5\u7ed3\u8bba\u3001\u5206\u7ea7\u3001\u75c5\u7076\u7ed3\u679c\u3001\u968f\u8bbf/\u6cbb\u7597\u5efa\u8bae\uff09+ \u5b8c\u6574 reasoning trace\uff08\u53ef\u6eaf\u6e90\uff09\u3002</p>"},{"location":"eyeagent/architecture_diagnosis/#agent","title":"Agent \u89d2\u8272","text":"<p>\u6ce8\uff1a\u7cfb\u7edf\u6b63\u9010\u6b65\u5408\u5e76\u4e3a\u201c\u5355\u4e00 Unified Agent\uff08\u914d\u7f6e\u9a71\u52a8\uff09\u201d\u67b6\u6784\uff0c\u4ee5\u4e0b\u5206\u89d2\u8272\u63cf\u8ff0\u7528\u4e8e\u9610\u91ca\u804c\u8d23\u8fb9\u754c\u4e0e\u63a8\u7406\u89c6\u89d2\uff0c\u5b9e\u9645\u8fd0\u884c\u65f6\u7531\u4e00\u4e2a\u7edf\u4e00 Agent \u4f9d\u636e YAML \u914d\u7f6e\u9009\u62e9\u5de5\u5177\u4e0e\u51b3\u7b56\u8def\u5f84\u3002 | Agent | \u529f\u80fd | \u4e3b\u8981\u5de5\u5177 | \u5173\u952e\u8f93\u51fa | |-------|------|----------|----------| | Orchestrator | \u6d41\u7a0b\u8c03\u5ea6\u3001\u6a21\u6001\u8bc6\u522b\u3001\u5de6\u53f3\u773c\u8bc6\u522b\u3001\u4efb\u52a1\u89c4\u5212 | \u6a21\u6001\u5206\u7c7b\u3001\u5de6\u53f3\u773c\u5206\u7c7b | \u8c03\u7528\u8def\u5f84\u3001\u51b3\u7b56 reasoning | | Image Analysis | \u5f71\u50cf\u8d28\u91cf\u3001\u75c5\u7076\u68c0\u6d4b\u3001\u521d\u6b65\u591a\u75be\u75c5\u5206\u7c7b | CFP \u8d28\u91cf\u5206\u7c7b\u3001\u75c5\u7076\u5206\u5272\u3001\u75be\u75c5\u591a\u5206\u7c7b | \u75c5\u7076\u7ed3\u6784\u3001\u521d\u6b65\u75be\u75c5\u5217\u8868\u3001reasoning | | Specialist | \u4e13\u75c5\u786e\u8bca/\u5206\u7ea7\u3001\u591a\u6a21\u6001\u91cf\u5316 | 32 \u7c7b\u4e13\u75c5\u5206\u7ea7\u6a21\u578b\u3001OCT/FFA \u5b9a\u91cf\u5206\u6790 | \u5404\u75be\u75c5\u5206\u7ea7\u3001\u8bc1\u636e\u3001reasoning | | Follow-up | \u98ce\u9669/\u8fdb\u5c55\u8bc4\u4f30\u3001\u7ba1\u7406\u7b56\u7565 | \u5e74\u9f84\u5206\u7c7b\u3001DR/AMD \u5206\u7ea7\u7ed3\u679c | \u968f\u8bbf/\u6cbb\u7597\u5efa\u8bae\u3001reasoning | | Report | \u6c47\u603b\u6240\u6709\u4e2d\u95f4\u7ed3\u679c\u5e76\u751f\u6210\u62a5\u544a | \uff08\u65e0\u9700\u5916\u90e8\u5de5\u5177\uff09 | Final Report + \u5168\u5c40 reasoning trace |</p>"},{"location":"eyeagent/architecture_diagnosis/#reasoning-trace","title":"Reasoning &amp; Trace \u673a\u5236","text":"<p>\u6240\u6709 Agent \u8f93\u51fa\u7edf\u4e00\u5305\u542b\uff1a</p> <pre><code>{\n  \"agent\": \"ImageAnalysisAgent\",\n  \"role\": \"image_analysis\",\n  \"inputs\": {...},\n  \"tool_calls\": [\n    {\"tool_id\": \"lesion_seg\", \"mcp_tool\": \"lesion_segmentation\", \"version\": \"1.0.0\", \"arguments\": {...}, \"output\": {...}, \"confidence\": 0.92, \"reasoning\": \"\u68c0\u6d4b\u9ec4\u6591\u533a\u51fa\u8840\"}\n  ],\n  \"outputs\": {\"lesions\": {...}, \"diseases\": [...]},\n  \"reasoning\": \"\u4f9d\u636e\u75c5\u7076\u7279\u5f81\u4e0e\u5206\u7c7b\u7ed3\u679c\u521d\u6b65\u5224\u65ad DR \u98ce\u9669\u3002\"\n}\n</code></pre>"},{"location":"eyeagent/architecture_diagnosis/#_3","title":"\u8bca\u65ad\u5de5\u4f5c\u6d41\uff08\u521d\u7248\u987a\u5e8f\uff0c\u53ef\u6269\u5c55\u6761\u4ef6\u5206\u652f\uff09","text":"<ol> <li>Orchestrator\uff1a\u8bc6\u522b\u6a21\u6001 + \u5de6\u53f3\u773c \u2192 \u89c4\u5212\u540e\u7eed\u8c03\u7528\uff08\u4f8b\u5982 CFP \u2192 ImageAnalysis \u2192 Specialist \u2192 FollowUp \u2192 Report\uff09</li> <li>Image Analysis\uff1a\u8d28\u91cf\u8fc7\u6ee4\u3001\u75c5\u7076\u63d0\u53d6\u3001\u521d\u6b65\u591a\u75be\u75c5\u5206\u7c7b</li> <li>Specialist\uff1a\u9488\u5bf9\u5019\u9009\u75be\u75c5\u8c03\u7528\u4e13\u75c5\u6a21\u578b\uff08\u52a8\u6001\u5b50\u96c6\uff09</li> <li>Follow-up\uff1a\u7ed3\u5408\u5e74\u9f84 + \u5206\u7ea7\u751f\u6210\u5efa\u8bae</li> <li>Report\uff1a\u805a\u5408\u6240\u6709\u6b65\u9aa4\u6210\u6700\u7ec8\u7ed3\u6784\u5316 JSON</li> </ol> <p>\u672a\u6765\u53ef\u901a\u8fc7\u56fe\u7ed3\u6784\uff08LangGraph / \u81ea\u5b9a\u4e49\u6709\u5411\u56fe\uff09\u5b9e\u73b0\u6761\u4ef6\u8df3\u8f6c\u3001\u5931\u8d25\u91cd\u8bd5\u3001\u66ff\u4ee3\u5de5\u5177\u56de\u9000\u3002</p>"},{"location":"eyeagent/architecture_diagnosis/#tool-registry","title":"\u5de5\u5177\u6ce8\u518c (Tool Registry)","text":"<p>\u96c6\u4e2d\u7ef4\u62a4\u5de5\u5177\u5143\u6570\u636e\uff08ID\u3001\u7248\u672c\u3001\u63cf\u8ff0\u3001\u652f\u6301\u6a21\u6001\u3001\u6240\u5c5e\u9636\u6bb5\u3001\u8f93\u51fa schema \u7b80\u8ff0\uff09\uff0c\u5e76\u5728\u8fd0\u884c\u65f6\u4e0e MCP server \u7684\u5b9e\u9645\u5de5\u5177\u540d\u79f0\u6620\u5c04\u3002\u652f\u6301\uff1a - \u6309\u89d2\u8272/\u6a21\u6001\u8fc7\u6ee4 - \u7248\u672c\u8ffd\u8e2a - Prompt \u751f\u6210\uff08\u7528\u4e8e text grad \u4f18\u5316\uff09</p> <p>\u793a\u4f8b\uff1a</p> <pre><code>TOOL_REGISTRY = {\n  \"modality_classify\": {\"mcp_name\": \"modality_classifier\", \"version\": \"1.0.0\", \"role\": \"orchestrator\", \"modalities\": [\"CFP\",\"OCT\",\"FFA\"], \"desc\": \"\u8bc6\u522b\u56fe\u50cf\u6a21\u6001\"},\n  \"dr_grading\": {\"mcp_name\": \"dr_grading_model\", \"version\": \"2.1.0\", \"role\": \"specialist\", \"disease\": \"DR\", \"desc\": \"\u7cd6\u5c3f\u75c5\u89c6\u7f51\u819c\u75c5\u53d8\u5206\u7ea7\"}\n}\n</code></pre>"},{"location":"eyeagent/architecture_diagnosis/#json","title":"JSON \u6700\u7ec8\u62a5\u544a\u7ed3\u6784","text":"<pre><code>{\n  \"case_id\": \"uuid\",\n  \"patient\": {\"patient_id\": \"P123\", \"age\": 63, \"gender\": \"M\"},\n  \"images\": [{\"image_id\": \"IMG001\", \"path\": \"...\", \"modality\": \"CFP\", \"eye\": \"OD\"}],\n  \"workflow\": [ /* \u6bcf\u4e2a agent \u7684\u8f93\u51fa\u5757\uff0c\u6309\u65f6\u95f4\u987a\u5e8f */ ],\n  \"final_report\": {\n    \"diagnoses\": [{\"disease\": \"DR\", \"grade\": \"R2\", \"confidence\": 0.91, \"evidence\": [\"microaneurysm\", \"hemorrhage\"]}],\n    \"lesions\": {\"hemorrhage\": 12, \"exudate\": 4},\n    \"management\": {\"follow_up_months\": 3, \"suggestion\": \"\u5efa\u8bae 3 \u4e2a\u6708\u540e\u590d\u67e5 OCT\"},\n    \"reasoning\": \"\u57fa\u4e8e\u591a\u75be\u75c5\u5206\u7c7b\u4e0e\u4e13\u75c5\u5206\u7ea7\u4e00\u81f4\u6027...\"\n  },\n  \"trace_log_path\": \"&lt;resolved path to trace.json&gt;\",\n  \"generated_at\": \"2025-09-17T12:00:00Z\",\n  \"schema_version\": \"1.0.0\"\n}\n</code></pre>"},{"location":"eyeagent/architecture_diagnosis/#_4","title":"\u9519\u8bef\u6eaf\u6e90\u7b56\u7565","text":"<ul> <li>\u6bcf\u4e2a\u5de5\u5177\u8c03\u7528\u4e8b\u4ef6\u8bb0\u5f55\uff1atool_id\u3001mcp_tool\u3001version\u3001inputs\u3001raw_output\u3001parsed_output\u3001confidence\u3001latency\u3001agent\u3001reasoning</li> <li>\u53d1\u751f\u9519\u8bef\u65f6\uff08\u5f02\u5e38\u6216\u4f4e\u7f6e\u4fe1\u5ea6\uff09\uff0c\u5199\u5165\u4e8b\u4ef6 <code>status = failed</code>\uff0c<code>error_type</code>\u3001<code>stack</code>\uff08\u53ef\u9009\uff09</li> <li>\u6eaf\u6e90\u62a5\u544a\u901a\u8fc7\u904d\u5386 <code>workflow</code> + <code>tool_calls</code>\uff0c\u5b9a\u4f4d\uff1a</li> <li>\u8c03\u5ea6\u9519\u8bef\uff1aOrchestrator reasoning \u4e0e\u5b9e\u9645\u540e\u7eed\u8c03\u7528\u4e0d\u4e00\u81f4</li> <li>\u75c5\u7076\u68c0\u6d4b\u9519\u8bef\uff1alesion seg \u8f93\u51fa\u7f3a\u5931 / \u4f4e\u7f6e\u4fe1\u4f46\u4ecd\u88ab\u4f7f\u7528</li> <li>\u5206\u7ea7\u9519\u8bef\uff1a\u4e13\u75c5\u5206\u7ea7\u7f6e\u4fe1\u5ea6\u4f4e\u6216\u4e0e\u521d\u6b65\u5206\u7c7b\u51b2\u7a81</li> </ul>"},{"location":"eyeagent/architecture_diagnosis/#prompt","title":"Prompt \u4f18\u5316\u51c6\u5907","text":"<ul> <li>Tool Registry \u652f\u6301 <code>desc_long</code>\uff0c\u9884\u7559\u66f4\u4e30\u5bcc\u4e0a\u4e0b\u6587</li> <li>Agent \u57fa\u7c7b\u751f\u6210 prompt \u65f6\u52a8\u6001\u62fc\u63a5\uff1a\u5f53\u524d\u75c5\u4f8b\u4e0a\u4e0b\u6587 + \u5df2\u6709\u4e2d\u95f4\u7ed3\u679c\u6458\u8981 + \u5de5\u5177\u5217\u8868 + \u671f\u671b JSON \u8f93\u51fa schema</li> <li>\u9884\u7559 <code>prompt_variants/</code> \u76ee\u5f55\u4fdd\u5b58\u6f14\u5316\u7248\u672c\uff0c\u7528\u4e8e text grad \u5bf9\u6bd4</li> </ul>"},{"location":"eyeagent/architecture_diagnosis/#_5","title":"\u76ee\u5f55\u7ed3\u6784\uff08\u7edf\u4e00\u7248\uff0c\u63a8\u8350\uff09","text":"<pre><code>eyeagent/\n  agents/\n    __init__.py\n    base_agent.py\n    diagnostic_base_agent.py      # \u5e26 reasoning \u4e0e trace hook\n    registry.py                   # \u914d\u7f6e\u9a71\u52a8\u7684 Agent \u52a0\u8f7d\uff08\u9ed8\u8ba4\u7edf\u4e00 Agent\uff09\n    # \u6ce8\uff1alegacy \u591a Agent \u6587\u4ef6\u4ecd\u5728\u4ed3\u5e93\u4e2d\uff0c\u5904\u4e8e\u5f03\u7528\u72b6\u6001\uff0c\u540e\u7eed\u5c06\u79fb\u9664\n  config/\n    settings.py\n    prompts.py\n    pipelines.py\n    tools_description.py\n  core/\n    interaction_engine.py\n    logging.py\n  llm/\n    json_client.py\n    models.py\n  tools/\n    tool_registry.py              # \u5de5\u5177\u5143\u6570\u636e &amp; \u67e5\u8be2\uff08\u652f\u6301\u6309\u914d\u7f6e\u7b5b\u9009\uff09\n    langchain_mcp_tools.py\n  tracing/\n    trace_logger.py               # \u7edf\u4e00\u4e8b\u4ef6/\u62a5\u544a\u6301\u4e45\u5316\n  ui/\n    app.py\n  schemas/\n    diagnosis_report_schema.json\n  diagnostic_workflow.py          # \u5de5\u4f5c\u6d41\u8c03\u5ea6\u5165\u53e3\uff08\u4f7f\u7528\u7edf\u4e00 Agent\uff09\n  run_diagnosis.py                # CLI \u5165\u53e3\uff08\u4f18\u5148\u4f7f\u7528\u8be5\u8def\u5f84\u4e0b\u7684\u811a\u672c\uff09\n</code></pre> <p>\u63d0\u793a\uff1a\u4ed3\u5e93\u6839\u76ee\u5f55\u4e0b\u7684 <code>diagnostic_workflow.py</code> \u4e0e <code>run_diagnosis.py</code> \u4e3a\u65e7\u7248\u91cd\u590d\u5165\u53e3\uff0c\u5df2\u5f03\u7528\uff0c\u540e\u7eed\u6e05\u7406\uff1b\u8bf7\u4f7f\u7528 <code>eyeagent/</code> \u76ee\u5f55\u4e0b\u7684\u5bf9\u5e94\u811a\u672c\u3002</p>"},{"location":"eyeagent/architecture_diagnosis/#legacy","title":"\u76ee\u5f55\u7ed3\u6784\uff08legacy\uff0c\u5f85\u79fb\u9664\uff09","text":"<p>\u4ee5\u4e0b\u4e3a\u65e9\u671f\u591a Agent \u5f62\u6001\u4e0b\u7684\u6587\u4ef6\uff0c\u4ec5\u4f9b\u5386\u53f2\u53c2\u8003\uff1a</p> <pre><code>eyeagent/\n  agents/\n    orchestrator_agent.py\n    image_analysis_agent.py\n    specialist_agent.py\n    followup_agent.py\n    report_agent.py\n</code></pre>"},{"location":"eyeagent/architecture_diagnosis/#_6","title":"\u6269\u5c55\u4e0e\u6d4b\u8bd5\u5efa\u8bae","text":"<ul> <li>\u5355\u5143\u6d4b\u8bd5\uff1a</li> <li>mock MCP \u5de5\u5177\u8fd4\u56de \u2192 \u9a8c\u8bc1 agent reasoning \u7ed3\u6784\u4e0e\u8f93\u51fa schema</li> <li>TraceLogger\uff1a\u4e8b\u4ef6\u987a\u5e8f\u3001\u6587\u4ef6\u5199\u5165\u3001\u5931\u8d25\u6807\u8bb0</li> <li>Orchestrator\uff1a\u8f93\u5165\u4e0d\u540c\u6a21\u6001\u7ec4\u5408 \u2192 \u89c4\u5212\u8def\u5f84\u6b63\u786e</li> <li>\u96c6\u6210\u6d4b\u8bd5\uff1a\u6a21\u62df\u4e00\u4efd CFP + \u60a3\u8005\u8d44\u6599 \u2192 \u751f\u6210\u5b8c\u6574 report JSON</li> </ul>"},{"location":"eyeagent/architecture_diagnosis/#_7","title":"\u5b89\u5168\u4e0e\u5408\u89c4","text":"<ul> <li>\u4ec5\u4fdd\u5b58\u53bb\u6807\u8bc6\u5316 patient_id</li> <li>\u4e0d\u5728\u65e5\u5fd7\u4e2d\u5199\u5165\u539f\u59cb\u5f71\u50cf\u50cf\u7d20\uff08\u4ec5\u8def\u5f84/ID\uff09</li> </ul>"},{"location":"eyeagent/architecture_diagnosis/#_8","title":"\u4e0b\u4e00\u6b65\uff08\u53ef\u9009\uff09","text":"<ul> <li>\u5f15\u5165\u914d\u7f6e\u9a71\u52a8\u7684 DAG\uff08YAML\uff09\u66ff\u4ee3\u786c\u7f16\u7801\u987a\u5e8f</li> <li>\u8d28\u91cf\u95e8\u63a7\uff1a\u81ea\u52a8\u68c0\u6d4b\u4f4e\u7f6e\u4fe1\u5ea6\u94fe\u8def\u5e76\u56de\u9000 / \u89e6\u53d1\u590d\u6838</li> <li>LLM reasoning \u88c1\u526a\u4e0e\u5408\u5e76\uff0c\u907f\u514d\u6cc4\u9732\u654f\u611f\u6570\u636e</li> </ul>"},{"location":"eyeagent/quickstart/","title":"Quick Start","text":""},{"location":"eyeagent/quickstart/#install","title":"Install","text":"<p>We recommend using uv for dependency management:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Then in the repository root:</p> <pre><code>uv sync\n</code></pre>"},{"location":"eyeagent/quickstart/#run-cli-diagnosis","title":"Run CLI (diagnosis)","text":"<p>The package exposes a CLI entrypoint that runs the workflow once:</p> <pre><code>uv run eyeagent-diagnose \\\n    --patient '{\"patient_id\":\"P001\",\"age\":63}' \\\n    --images '[{\"image_id\":\"IMG001\",\"path\":\"/path/to/cfp.jpg\"}]'\n</code></pre> <p>To avoid calling external services while exploring, enable dry-run:</p> <pre><code>export EYEAGENT_DRY_RUN=1\nuv run eyeagent-diagnose --patient '{\"patient_id\":\"P001\"}' --images '[{\"image_id\":\"I1\",\"path\":\"/tmp/od.jpg\"}]'\n</code></pre>"},{"location":"eyeagent/quickstart/#run-ui","title":"Run UI","text":"<p>Launch a simple Gradio UI that streams tool/agent steps:</p> <pre><code>uv run eyeagent-ui --port 7860\n</code></pre> <p>By default, workflow mode is unified unless overridden in <code>eyeagent/config/eyeagent.yml</code>. We have set it to <code>profile</code> in this repo so that the multi-agent pipeline runs via <code>pipelines.yml</code>. To explicitly select the default profile at runtime:</p> <pre><code>export EYEAGENT_PIPELINE_PROFILE=default\nuv run eyeagent-ui --mcp-url \"http://localhost:8000/mcp\" --port 7860\n</code></pre>"},{"location":"eyeagent/quickstart/#test","title":"Test","text":""},{"location":"eyeagent/quickstart/#knowledge-step-rag-pubmed","title":"Knowledge step (RAG / PubMed)","text":"<p>If your MCP server exposes the tools <code>rag:query</code> and <code>web_search:pubmed</code>, EyeAgent will run a knowledge step between specialist and follow-up when using the <code>default</code> profile.</p> <ul> <li>Or use the demo runner:</li> </ul> <pre><code>uv run python -m eyeagent.run_ophthalmology_demo\n</code></pre> <p>Tool contracts (normalized): - rag:query args: <code>{ \"query\": string, \"top_k\"?: number }</code> \u2192 <code>{ items: [{ title?, text?, source?, score? }], source: \"rag\" }</code> - web_search:pubmed args: <code>{ \"query\": string, \"top_k\"?: number }</code> \u2192 <code>{ items: [{ id?, title?, abstract?, url?, year? }], source: \"pubmed\" }</code></p> <p>You can remap tool IDs via <code>eyeagent/config/tools.yml</code>.</p> <pre><code>uv run pytest -q\n</code></pre>"},{"location":"eyetools/","title":"EyeTools Documentation","text":"<p>Welcome to the EyeTools framework docs. This folder provides an overview, architecture, per-module reference, testing practices and contribution guide.</p>"},{"location":"eyetools/#contents","title":"Contents","text":"<ul> <li>Quick Start</li> <li>Architecture Overview</li> <li>Module docs (modules/*.md)</li> <li>Testing &amp; Quality</li> <li>Contributing</li> </ul>"},{"location":"eyetools/#unified-output-contract","title":"Unified Output Contract","text":"<p>All tools should return plain JSON with minimal shaping. Common fields where applicable:</p> <ul> <li>prediction or label: the primary predicted class or value</li> <li>probabilities: map of label -&gt; probability for classification-like tools</li> <li>inference_time: seconds spent inside the tool (optional)</li> <li>counts/areas/output_paths: for segmentation-style tools</li> </ul> <p>The MCP server returns a pass-through envelope with meta:</p> <p>{ \"output\": , \"meta\": { \"tool_id\": \"...\", \"inputs\": {...}, \"ts\":  } } <p>Framework layers unwrap the envelope and attach <code>mcp_meta</code> to traces so the UI can show tool name and time.</p>"},{"location":"eyetools/architecture/","title":"Architecture Overview","text":"<p>EyeTools has two layers: 1. Legacy/compat layer <code>eyetools/</code> 2. New core under <code>eyetools/core/</code> (discovery, registration, scheduling, runtime)</p> <p>Core flow:</p> <pre><code>discover (loader.discover_tools) -&gt; parse config (config_loader) -&gt; register (registry.ToolRegistry) -&gt;\nToolManager chooses inproc | subprocess based on load_mode -&gt; lazy model load -&gt; predict -&gt; metrics &amp; lifecycle management\n</code></pre>"},{"location":"eyetools/architecture/#key-modules","title":"Key Modules","text":"<ul> <li>config_loader: parse config (single / variants / tools), normalize + defaults.</li> <li>registry: holds ToolMeta (thread-safe).</li> <li>loader: walks paths, calls config_loader, registers ToolMeta.</li> <li>tool_manager: predict dispatch, inproc instance cache, subprocess workers, metrics &amp; lifecycle (LOADED/IDLE/UNLOADED).</li> <li>process_manager: spawn workers &amp; JSON line protocol IPC.</li> <li>env_manager: compose <code>uv run</code> invocation with python tag + extra dependencies.</li> <li>role_router: role-based include/exclude + tag filtering.</li> <li>logging: core_logger utilities.</li> <li>worker_entry / worker_protocol: worker process protocol implementation.</li> <li>mcp_server: FastAPI app exposing health/tools/predict/metrics with role filtering.</li> <li>cli: command entry launching uvicorn.</li> </ul>"},{"location":"eyetools/architecture/#lifecycle-lazy-loading","title":"Lifecycle &amp; Lazy Loading","text":"<p>ToolManager states: - REGISTERED -&gt; first inproc predict creates instance (prepare) -&gt; LOADED - mark_idle transitions LOADED -&gt; IDLE (time-based) - unload_idle transitions IDLE -&gt; UNLOADED (eviction) - next predict reloads -&gt; LOADED</p>"},{"location":"eyetools/architecture/#execution-modes","title":"Execution Modes","text":"<ul> <li>inproc: direct import + instantiate.</li> <li>subprocess: ProcessManager spawns worker.</li> </ul>"},{"location":"eyetools/architecture/#metrics","title":"Metrics","text":"<ul> <li>predict_count, total_latency_ms, last_latency_ms, avg_latency_ms</li> <li>aggregate summary under <code>__aggregate__</code>.</li> </ul>"},{"location":"eyetools/contributing/","title":"Contributing Guide","text":""},{"location":"eyetools/contributing/#workflow","title":"Workflow","text":"<ol> <li>Fork &amp; create a feature branch</li> <li>Add/update tests (must pass <code>uv run pytest -q</code>)</li> <li>Update relevant docs</li> <li>Open a PR describing motivation, changes, impact</li> </ol>"},{"location":"eyetools/contributing/#code-style","title":"Code Style","text":"<ul> <li>Keep functions small &amp; cohesive</li> <li>Any new public API must update module docs</li> </ul>"},{"location":"eyetools/contributing/#testing-expectations","title":"Testing Expectations","text":"<ul> <li>Cover success &amp; failure paths</li> <li>Subprocess / network tests must run on CI without GPUs</li> </ul>"},{"location":"eyetools/quickstart/","title":"Quick Start","text":""},{"location":"eyetools/quickstart/#environment","title":"Environment","text":"<p>The project uses <code>uv</code> for dependency and multi-Python management. Install <code>uv</code>:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>See the official docs for alternative installation methods.</p>"},{"location":"eyetools/quickstart/#install-dependencies","title":"Install Dependencies","text":"<pre><code>uv sync\n</code></pre>"},{"location":"eyetools/quickstart/#run-tests","title":"Run Tests","text":"<pre><code>uv run pytest -q\n</code></pre>"},{"location":"eyetools/quickstart/#launch-mcp-server","title":"Launch MCP Server","text":"<p>Basic run (will auto-load local <code>./tools</code> directory if it exists):</p> <pre><code>uv run eyetools-mcp serve --host 0.0.0.0 --port 8000\n</code></pre> <p>Add examples and an explicit tools directory (repeat <code>--tools-dir</code> to add multiple roots):</p> <pre><code>uv run eyetools-mcp serve --host 0.0.0.0 --port 8000 --include-examples --tools-dir tools\n</code></pre> <p><code>--tools-dir</code> is an alias of <code>--tool-path</code>; both are accepted.</p>"},{"location":"eyetools/quickstart/#lifecycle-modes","title":"Lifecycle Modes","text":"<p>Select how tools are loaded / unloaded:</p> <ul> <li><code>eager</code> (default): preload every tool (inproc + subprocess) at startup.</li> <li><code>lazy</code>: load on first request only.</li> <li><code>dynamic</code>: lazy plus a background loop that marks tools idle and unloads them after inactivity thresholds.</li> </ul> <p>Flags:</p> <pre><code>--lifecycle-mode {eager|lazy|dynamic}\n--dynamic-mark-idle-s &lt;seconds&gt;\n--dynamic-unload-s &lt;seconds&gt;\n--dynamic-interval-s &lt;seconds&gt;\n</code></pre> <p>Examples:</p> <pre><code># Lazy mode (on-demand)\nuv run eyetools-mcp serve --lifecycle-mode lazy\n\n# Dynamic: mark idle after 5m, unload after 15m, sweep every minute\nuv run eyetools-mcp serve --lifecycle-mode dynamic \\\n    --dynamic-mark-idle-s 300 --dynamic-unload-s 900 --dynamic-interval-s 60\n</code></pre> <p>Legacy flags kept for backward compatibility (ignored if lifecycle-mode provided):</p> <pre><code>--preload            # preload all inproc tools\n--preload-subprocess # also preload subprocess tools\n</code></pre> <p><code>eager</code> mode supersedes these (always preloads everything). Use them only if you keep older scripts without updating to <code>--lifecycle-mode</code>.</p> <p>Open http://localhost:8000/docs to view the FastAPI interactive docs.</p>"},{"location":"eyetools/quickstart/#tool-discovery","title":"Tool Discovery","text":"<p>Use one (or many) <code>--tools-dir</code> / <code>--tool-path</code> flags to point at directories containing tool packages. You can also set environment variables:</p> <ul> <li><code>EYETOOLS_TOOL_PATHS</code> (colon separated)</li> <li><code>EYETOOLS_EXTRA_TOOL_PATHS</code> (colon separated)</li> </ul> <p>If neither flags nor env vars are provided and a local <code>./tools</code> directory exists, it will be used automatically.</p> <p>See <code>examples/tool_package_template</code> for a reference structure.</p>"},{"location":"eyetools/quickstart/#management-endpoints","title":"Management Endpoints","text":"<p>Additional operational endpoints are exposed:</p> <ul> <li><code>GET /lifecycle</code> \u2013 current lifecycle states for instantiated tools.</li> <li><code>POST /admin/reload</code> \u2013 rediscover tools (query param <code>preload_models=true</code> to eagerly load again).</li> <li><code>GET /metrics</code> \u2013 aggregated latency &amp; count metrics. Add <code>?tool_id=&lt;id&gt;</code> for one tool.</li> <li><code>POST /admin/preload/{tool_id}</code> \u2013 for inproc: instantiate &amp; load; for subprocess: start worker.</li> <li><code>POST /admin/evict?tool_id=&lt;id&gt;</code> \u2013 unload an inproc tool or terminate a subprocess worker.</li> <li><code>GET /lifecycle?detailed=true</code> \u2013 include <code>last_used</code> timestamp &amp; loaded flag per tool.</li> <li><code>GET /admin/resources</code> \u2013 snapshot of counts, RSS memory, aggregate metrics (GPU if available).</li> <li><code>POST /admin/maintenance</code> \u2013 run idle marking/unloading. Params: <code>mark_idle_s</code>, <code>unload_idle_s</code>.</li> </ul> <p>These can be useful after adding new tool directories at runtime.</p>"},{"location":"eyetools/quickstart/#quick-examples","title":"Quick Examples","text":"<p>Preload a single tool:</p> <pre><code>curl -X POST http://localhost:8000/admin/preload/classification:modality\n</code></pre> <p>Evict it again:</p> <pre><code>curl -X POST 'http://localhost:8000/admin/evict?tool_id=classification:modality'\n</code></pre> <p>Inspect detailed lifecycle:</p> <pre><code>curl 'http://localhost:8000/lifecycle?detailed=true'\n</code></pre> <p>Tool-specific metrics:</p> <pre><code>curl 'http://localhost:8000/metrics?tool_id=classification:modality'\n</code></pre> <p>Resource snapshot:</p> <pre><code>curl http://localhost:8000/admin/resources\n</code></pre> <p>Run maintenance (mark idle &gt;300s &amp; unload idle &gt;900s, sequential calls):</p> <pre><code>curl -X POST 'http://localhost:8000/admin/maintenance?mark_idle_s=300'\ncurl -X POST 'http://localhost:8000/admin/maintenance?unload_idle_s=900'\n</code></pre>"},{"location":"eyetools/testing/","title":"Testing &amp; Quality","text":"<p>Current coverage: - Discovery: test_discovery - Classification placeholder functions: test_classification - Metrics &amp; errors: test_metrics_and_errors - Role routing: test_role_router - ToolManager inproc/subprocess: test_tool_manager_inproc / test_tool_manager_subprocess - Added config/env/process/cli/server coverage.</p>"},{"location":"eyetools/testing/#minimal-mcp-server-test","title":"Minimal MCP Server Test","text":"<p>For fast CI signal we maintain a minimal MCP smoke test that: 1. Starts the FastAPI app with MCP enabled (automatic if <code>fastmcp</code> installed) 2. Supplies an empty <code>tool_paths</code> list (or points <code>EYETOOLS_TOOL_PATHS</code> to an empty directory) 3. Asserts <code>/mcp/tools</code> returns an empty tool list with <code>enabled: true</code></p> <p>Example:</p> <pre><code>from eyetools.mcp_server import create_app\nfrom fastapi.testclient import TestClient\n\ndef test_mcp_server_basic():\n    app = create_app(include_examples=False, tool_paths=[])\n    c = TestClient(app)\n    data = c.get('/mcp/tools').json()\n    assert data['enabled'] is True\n    assert data['count'] == 0\n</code></pre> <p>Run just this test:</p> <pre><code>pytest -q tests/test_mcp_server.py::test_mcp_server_basic --maxfail=1\n</code></pre> <p>More advanced MCP behavior (param styles, refresh) is documented in <code>docs/modules/mcp.md</code> and can be covered by incremental tests later.</p> <p>Potential future additions: - Lifecycle eviction tests (mark_idle / unload_idle) - Worker error propagation &amp; timeout path - Coverage &amp; mutation testing (pytest-cov, mutmut)  - Expanded MCP tests (explicit vs kwargs vs payload fallback)  - <code>/mcp/refresh</code> behavior &amp; post-reload re-registration</p>"},{"location":"eyetools/modules/config/","title":"Config Management (config_loader)","text":"<p>Parsing logic: 1. Read YAML or Python (<code>config.yaml</code> / <code>config.py</code>); Python must expose <code>get_config()</code> or <code>CONFIGS</code>. 2. Determine mode: single / variants / tools. 3. For variants: merge <code>shared</code> + each variant (nested merge for runtime/model/warmup/io). 4. Generate ID priority: id -&gt; package:variant -&gt; package -&gt; name -&gt; entry class. 5. Apply defaults: runtime(load_mode=auto, queue_size, idle_timeout_s ...), model(precision=device=auto, lazy=True), etc. 6. Validate: entry format, precision, load_mode.</p> <p>Output: normalized list[ToolDefinition] for loader registration.</p>"},{"location":"eyetools/modules/env_process/","title":"Environment &amp; Process Management","text":""},{"location":"eyetools/modules/env_process/#envmanager","title":"EnvManager","text":"<ul> <li>Build env_key from (python_tag + extra_requires).</li> <li>Execute commands via <code>uv run --with deps --python=&lt;tag&gt;</code>.</li> </ul>"},{"location":"eyetools/modules/env_process/#processmanager","title":"ProcessManager","text":"<ul> <li>spawn: compose uv run (or system python) to start worker_entry.</li> <li>request: JSON line protocol over stdin/stdout.</li> <li>ensure_init: send INIT, track _init_done.</li> <li>cleanup_idle: terminate idle workers by last_used timestamp.</li> </ul>"},{"location":"eyetools/modules/mcp/","title":"MCP Integration","text":"<p>This module integrates the EyeTools server with FastMCP (Model Context Protocol) so MCP-compatible clients can discover and invoke tools.</p>"},{"location":"eyetools/modules/mcp/#key-capabilities","title":"Key Capabilities","text":"<ul> <li>Optional activation (disable via <code>enable_mcp=False</code> or omit <code>fastmcp</code> dependency)</li> <li>Automatic registration of all discovered tools after registry population (before any eager preload)</li> <li>Multiple parameter mapping strategies (in order):</li> <li>explicit (generated async function with explicit parameters inferred from <code>input_schema</code> or <code>meta.io</code>)</li> <li>kwargs (single <code>**kwargs</code> entry point)</li> <li>payload (single dictionary argument) \u2013 fallback for older FastMCP builds that reject <code>**kwargs</code></li> <li>Input schema best-effort inference from <code>ToolMeta.io</code> (<code>io.input</code> if present, else treat remaining keys as string properties)</li> <li>Reload-safe re\u2011registration (<code>/admin/reload</code> triggers <code>_mcp_reregister</code>)</li> <li>Introspection endpoint <code>/mcp/tools</code> with: name, description, input_schema, param_style, lifecycle_state</li> <li>Manual refresh without re-discovery: <code>POST /mcp/refresh</code></li> </ul>"},{"location":"eyetools/modules/mcp/#environment-variables","title":"Environment Variables","text":"Variable Purpose Default <code>EYETOOLS_MCP_MOUNT_PATH</code> Change mount path for MCP app (<code>/</code> or <code>/mcp</code> etc.) <code>/</code> <code>EYETOOLS_MCP_COMPAT_MOUNT</code> Also mount at <code>/mcp</code> when using custom path (set to <code>1</code>) disabled <code>EYETOOLS_MCP_PREFER_EXPLICIT</code> Disable explicit param generation when set to <code>0</code> <code>1</code>"},{"location":"eyetools/modules/mcp/#lifecycle-strategy","title":"Lifecycle Strategy","text":"<p>MCP registration occurs after tools are DISCOVERED + REGISTERED but before any eager preload. UNLOADED / IDLE states do not remove MCP routes: calls lazily re-load tools. <code>/admin/reload</code> rebuilds registry, then <code>_mcp_reregister</code> reconstructs MCP registration.</p>"},{"location":"eyetools/modules/mcp/#minimal-server-test-fast-path","title":"Minimal Server Test (Fast Path)","text":"<p>Run only the MCP server test without loading all heavy tool packages.</p>"},{"location":"eyetools/modules/mcp/#1-create-a-temporary-minimal-tool-config","title":"1. Create a temporary minimal tool config","text":"<p>If you want to avoid scanning the full <code>tools/</code> tree, point to an empty temp directory.</p> <pre><code>mkdir -p /tmp/eyetools-empty\nexport EYETOOLS_TOOL_PATHS=/tmp/eyetools-empty\n</code></pre> <p>This ensures discovery yields zero tools but server endpoints still initialize.</p>"},{"location":"eyetools/modules/mcp/#2-run-the-single-test-file","title":"2. Run the single test file","text":"<pre><code>pytest -q tests/test_mcp_server.py::test_mcp_server_basic \\\n  -k mcp_server_basic \\\n  --maxfail=1 --disable-warnings\n</code></pre> <p>(You can remove the <code>-k</code> if you want the whole file.)</p>"},{"location":"eyetools/modules/mcp/#3-run-with-mcp-enabled-but-no-tools-validation-only","title":"3. Run with MCP enabled but no tools (validation only)","text":"<pre><code>python - &lt;&lt;'PY'\nfrom eyetools.mcp_server import create_app\nfrom fastapi.testclient import TestClient\napp = create_app(include_examples=False, tool_paths=[])  # No discovery\nc = TestClient(app)\nprint('health:', c.get('/health').json())\nprint('mcp tools:', c.get('/mcp/tools').json())\nPY\n</code></pre> <p>Expected output should show <code>tools: 0</code> and <code>enabled: true</code> if <code>fastmcp</code> is installed.</p>"},{"location":"eyetools/modules/mcp/#4-overriding-mount-path","title":"4. Overriding Mount Path","text":"<pre><code>EYETOOLS_MCP_MOUNT_PATH=/mcp uvicorn eyetools.mcp_server:create_app --factory --port 8001\n</code></pre> <p>Then visit: <code>http://127.0.0.1:8001/mcp/tools</code>.</p>"},{"location":"eyetools/modules/mcp/#5-refresh-mcp-registration","title":"5. Refresh MCP Registration","text":"<p>After manual changes (e.g., env flips):</p> <pre><code>curl -X POST http://127.0.0.1:8001/mcp/refresh\n</code></pre>"},{"location":"eyetools/modules/mcp/#adding-a-lightweight-test-case-optional","title":"Adding a Lightweight Test Case (Optional)","text":"<p>You can add a focused test that asserts payload shape when no tools are discovered:</p> <pre><code># tests/test_mcp_tools_introspection.py\nfrom eyetools.mcp_server import create_app\nfrom fastapi.testclient import TestClient\n\ndef test_mcp_tools_empty():\n    app = create_app(include_examples=False, tool_paths=[])\n    client = TestClient(app)\n    data = client.get('/mcp/tools').json()\n    assert data['enabled'] is True\n    assert data['count'] == 0\n</code></pre>"},{"location":"eyetools/modules/mcp/#troubleshooting","title":"Troubleshooting","text":"Symptom Cause Action <code>enabled: false</code> in <code>/mcp/tools</code> <code>fastmcp</code> not installed <code>pip install fastmcp</code> All tools show <code>param_style=payload</code> Old FastMCP rejects <code>**kwargs</code> &amp; explicit build failed Upgrade <code>fastmcp</code> or inspect logs for explicit build errors Missing new tool after reload Not re-registered Call <code>POST /mcp/refresh</code> or use <code>/admin/reload</code> 404 invoking tool via MCP Tool id mismatch Verify <code>tool_id</code> from <code>/mcp/tools</code> exactly"},{"location":"eyetools/modules/mcp/#future-extensions","title":"Future Extensions","text":"<ul> <li>Output schema adaptation if model returns structured artifacts</li> <li>Auth / role filtering on MCP layer</li> <li>Tool disable/unregister endpoint</li> <li>Streaming predict wrapper</li> </ul> <p>This document complements <code>docs/testing.md</code> and focuses specifically on MCP behavior.</p>"},{"location":"eyetools/modules/mcp_cli_logging/","title":"CLI / MCP Server / Logging","text":""},{"location":"eyetools/modules/mcp_cli_logging/#cli","title":"CLI","text":"<p>Command: <code>eyetools-mcp serve</code> supports host/port/tool-path/include-examples/role-config/reload.</p>"},{"location":"eyetools/modules/mcp_cli_logging/#mcp-server-routes","title":"MCP Server Routes","text":"<ul> <li>GET /health: health status</li> <li>GET /tools?role=xxx: role-filtered tool list</li> <li>POST /predict: {tool_id, request, role?}</li> <li>GET /metrics: metrics snapshot</li> </ul>"},{"location":"eyetools/modules/mcp_cli_logging/#logging","title":"Logging","text":"<ul> <li>core_logger: unified debug output for core modules.</li> </ul>"},{"location":"eyetools/modules/registry/","title":"Tool Registry (registry)","text":"<p>Core data structure <code>ToolMeta</code>: - id, entry, version, runtime, model, params, tags, root_dir, extra_requires, python, category.</p> <p>Operations: - register(meta): reject duplicate id. - get(id), list(), remove(id), clear().</p> <p>Thread safety: internal RLock for mutation.</p>"},{"location":"eyetools/modules/role_router/","title":"Role Router (RoleRouter)","text":"<p>Filter order: include -&gt; exclude -&gt; tags_any -&gt; tags_all. select_mode=manual returns candidate list requiring external selection.</p> <p>Example config:</p> <pre><code>roles:\n  doctor:\n    include: [\"vision.*\"]\n    exclude: [\"*.experimental\"]\n    tags_any: [\"vision\"]\n    tags_all: [\"stable\"]\n    select_mode: auto\n</code></pre>"},{"location":"eyetools/modules/segmentation/","title":"Segmentation Tool (nnUNetv2)","text":"<p>The <code>segmentation</code> tool package provides multiple medical image segmentation tasks (CFP, OCT, FFA) backed by pretrained nnUNetv2 models.</p>"},{"location":"eyetools/modules/segmentation/#environment","title":"Environment","text":"<ul> <li>Environment reference: <code>py312-seg</code></li> <li>Defined at: <code>envs/py312-seg/pyproject.toml</code></li> <li>Heavy dependencies (torch, nnunetv2, SimpleITK, batchgenerators, etc.) are isolated from the base environment to keep core startup fast.</li> </ul>"},{"location":"eyetools/modules/segmentation/#variants","title":"Variants","text":"<p>See <code>tools/segmentation/config.yaml</code> for the full list (<code>cfp_*</code>, <code>oct_*</code>, <code>ffa_lesion</code>). Each variant maps to an internal dataset/model id via inlined configuration.</p>"},{"location":"eyetools/modules/segmentation/#usage","title":"Usage","text":"<p>Programmatic example:</p> <pre><code>from pathlib import Path\nfrom eyetools.core.registry import ToolRegistry\nfrom eyetools.core.loader import discover_tools\nfrom eyetools.core.tool_manager import ToolManager\n\nreg = ToolRegistry()\ndiscover_tools([Path('tools')], reg, [])\nmanager = ToolManager(registry=reg, workspace_root=Path('.'))\n\nseg_tool_id = next(m.id for m in reg.list() if m.id.endswith('segmentation:cfp_DR'))\nresult = manager.predict(seg_tool_id, {\"inputs\": {\"image_path\": \"sample.jpg\"}})\nprint(result)\n</code></pre>"},{"location":"eyetools/modules/segmentation/#weights","title":"Weights","text":"<p>Expected under <code>weights/segmentation/</code> with nnUNet folder naming: <code>DatasetXYZ_*</code>. The code searches for the prefix matching the resolved model id and loads <code>checkpoint_final.pth</code>.</p>"},{"location":"eyetools/modules/segmentation/#outputs","title":"Outputs","text":"<p>The tool returns JSON with: - <code>counts</code>: object with lesion -&gt; instance count - <code>areas</code>: object with lesion -&gt; list of contour areas - <code>output_paths</code>: merged, colorized, overlay image paths - <code>inference_time</code>: seconds</p>"},{"location":"eyetools/modules/segmentation/#testing-strategy","title":"Testing Strategy","text":"<p>Tests can mock the predictor to avoid downloading weights: patch <code>SegmentationTool.load_model</code> to inject a dummy predictor producing a synthetic mask.</p>"},{"location":"eyetools/modules/segmentation/#cli-example","title":"CLI Example","text":"<p>You can launch the MCP server and access segmentation tools:</p> <pre><code>uv run --python=python3.12 eyetools-mcp serve --tools-dir tools --host 0.0.0.0 --port 8000\n</code></pre> <p>Then pick the discovered tool id (e.g. <code>vision.segmentation:cfp_artifact</code>) from registry listing.</p>"},{"location":"eyetools/modules/segmentation/#dependency-decoupling","title":"Dependency Decoupling","text":"<p>The implementation is self-contained; all lesion color and model id mapping logic lives inside <code>tools/segmentation/tool_impl.py</code> with no dependency on <code>langchain_tool_src</code>.</p>"},{"location":"eyetools/modules/segmentation/#notes","title":"Notes","text":"<ul> <li>Heavy nnUNet inference is only triggered on first prediction (lazy load).</li> <li>Mock test <code>test_segmentation_mock_predict</code> ensures CI stays lightweight.</li> </ul>"},{"location":"eyetools/modules/segmentation/#demo-scripts","title":"Demo Scripts","text":"<p>Two helper scripts illustrate real vs. fallback inference and a simple MCP client interaction.</p>"},{"location":"eyetools/modules/segmentation/#scriptsdemo_segmentationpy","title":"<code>scripts/demo_segmentation.py</code>","text":"<p>Run a segmentation variant on a sample image. Supports two modes:</p> <ul> <li><code>real</code> (default): attempts to load nnUNet model weights under <code>weights/segmentation/</code>.</li> <li><code>fallback</code>: skips model loading and produces a synthetic mask so you can observe the output structure instantly.</li> </ul> <p>Example (fallback for quick preview):</p> <pre><code>python scripts/demo_segmentation.py \\\n    --variant cfp_artifact \\\n    --image examples/test_images/Artifact.jpg \\\n    --mode fallback\n</code></pre> <p>Attempt real inference (requires proper nnUNet weights present):</p> <pre><code>python scripts/demo_segmentation.py \\\n    --variant cfp_artifact \\\n    --image examples/test_images/Artifact.jpg\n</code></pre> <p>Outputs (merged mask, colorized label map, overlay) are written next to the input image with suffixes, and a JSON summary is printed.</p>"},{"location":"eyetools/modules/segmentation/#scriptsmcp_client_demopy","title":"<code>scripts/mcp_client_demo.py</code>","text":"<p>Illustrates how an MCP client could call the segmentation tool through the running server. Adapt this script for integration into your own agent or UI layer.</p> <p>If you invoke these scripts from within a subdirectory, they dynamically insert the project root into <code>sys.path</code> so imports remain robust.</p>"},{"location":"eyetools/modules/tool_loading/","title":"Tool Loading &amp; Import Path Resolution","text":"<p>This document explains how the <code>ToolManager</code> dynamically imports tool implementations and how import paths are stabilized to avoid intermittent <code>ImportError</code> issues (e.g. <code>attempted relative import with no known parent package</code>).</p>"},{"location":"eyetools/modules/tool_loading/#overview","title":"Overview","text":"<p>Tools are registered with metadata containing: - <code>id</code>: unique tool id (e.g. <code>classification:cfp_quality</code>) - <code>entry</code>: string of the form <code>module_name:ClassName</code> (e.g. <code>tool_impl:ClassificationTool</code>) - <code>root_dir</code>: filesystem directory where the tool implementation file(s) live</p> <p>When a tool is first needed (preload or on-demand), <code>ToolManager._import_entry</code> resolves the module + class and instantiates the tool.</p>"},{"location":"eyetools/modules/tool_loading/#previous-fragility","title":"Previous Fragility","text":"<p>Originally the manager tried to <code>import_module(module_name)</code> first and only inserted <code>root_dir</code> into <code>sys.path</code> if that failed. In some runtime contexts (different CWD, packaged invocation, parallel preload), Python could treat the module as a top-level script without its package context, breaking relative imports such as:</p> <pre><code>from .class_lists import TASK_CLASS_MAP\n</code></pre> <p>This manifested as:</p> <pre><code>ImportError: attempted relative import with no known parent package\n</code></pre> <p>followed by a failed fallback absolute import.</p>"},{"location":"eyetools/modules/tool_loading/#current-strategy-stabilized","title":"Current Strategy (Stabilized)","text":"<p>Before importing the module, <code>_import_entry</code> now always: 1. Inserts the tool's <code>root_dir</code> near the front of <code>sys.path</code> (index 0 or 1) if not already present. 2. Emits a DEBUG log line of the form:    <code>[import] inserted tool root into sys.path index=1 root=/abs/path/to/tool module=tool_impl</code>    or, if already present:    <code>[import] tool root already in sys.path root=/abs/path/to/tool module=tool_impl</code> 3. Calls <code>import_module(module_name)</code>. 4. If the class is not found (name collision or ambiguous <code>tool_impl.py</code>), it attempts a direct file-based import as a fallback.</p> <p>This deterministic insertion ensures relative imports inside the tool module reliably resolve.</p>"},{"location":"eyetools/modules/tool_loading/#security-ordering-notes","title":"Security &amp; Ordering Notes","text":"<ul> <li>The path is inserted after an empty string (<code>''</code>) entry if present (Python's indicator for the current working directory) to reduce the chance of shadowing first-party libraries.</li> <li>No existing entries are removed; the operation is idempotent.</li> <li>Tools should avoid using very generic module names to minimize collision risk (<code>tool_impl</code> is acceptable but unique names are better for large ecosystems).</li> </ul>"},{"location":"eyetools/modules/tool_loading/#debugging-tips","title":"Debugging Tips","text":"<p>Enable DEBUG logging for the <code>eyetools.core</code> logger to see import resolution messages:</p> <pre><code>export EYETOOLS_LOG_LEVEL=DEBUG\nuv run eyetools-mcp serve --log-dir logs --lifecycle-mode eager --host 0.0.0.0 --port 8000 --tools-dir tools\n</code></pre> <p>(Adjust environment variable name if your logging configuration differs.)</p> <p>If you still encounter an <code>ImportError</code>: 1. Confirm the tool directory contains an <code>__init__.py</code> if you intend it to be a package. 2. Check that no other earlier <code>sys.path</code> entry contains a conflicting module filename. 3. Inspect the DEBUG log lines for which path was inserted and in what order.</p>"},{"location":"eyetools/modules/tool_loading/#recommendations-for-tool-authors","title":"Recommendations for Tool Authors","text":"<ul> <li>Provide unique <code>module_name</code> values when possible (e.g. <code>retfound_cls_tool</code> instead of a generic <code>tool_impl</code>).</li> <li>Keep relative imports (<code>from .submodule import X</code>) for intra-tool code; they remain valid across relocations.</li> <li>Avoid side effects at import time that depend on external services; defer heavy initialization to <code>ensure_model_loaded()</code> or an explicit <code>prepare()</code> method.</li> </ul>"},{"location":"eyetools/modules/tool_loading/#future-improvements","title":"Future Improvements","text":"<p>Potential enhancements under consideration: - Optional hashing of tool roots to construct synthetic, collision-resistant module namespaces. - Warn (INFO) when multiple different roots provide the same <code>module_name</code>. - Provide a CLI flag to dump final <code>sys.path</code> after tool discovery.</p> <p>Last updated: 2025-09-16</p>"},{"location":"eyetools/modules/tool_manager/","title":"Tool Management (ToolManager)","text":"<p>Responsibilities: - Dispatch prediction (inproc / subprocess) - Instance cache + LRU eviction - Lifecycle tracking (REGISTERED/LOADED/IDLE/UNLOADED) - Metrics collection</p> <p>Key logic: - get_or_create_inproc: import entry, instantiate, optional prepare(). - predict: branch on runtime.load_mode; lazy model loading; update metrics. - mark_idle / unload_idle: state transitions &amp; memory release.</p>"}]}